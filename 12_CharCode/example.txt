システムプログラミング　宿題の解答

問題：半角英数字,半角カナ,全角カナ,漢字,\,¥等を含むテキストファイルを
　　　観察する。

1. UTF-8エンコーディングのテキストファイルを作り表示してみた

$ cat x0208UTF8.txt    // 含まれる漢字はJIS X 0208の範囲まで
Aｱア漢¥\

2. 色々なエンコーディングに変換して16進ダンプを確認する

// UTF-32 にエンコードしてUnicode値を確認しておく
$ iconv -f UTF-8 -t UTF-32BE x0208UTF8.txt | hexdump
// UTF-32BE(ビッグエンディアン):32ビットの上位桁からのバイト順
0000000 00 00 00 41 00 00 ff 71 00 00 30 a2 00 00 6f 22
0000010 00 00 00 a5 00 00 00 5c 00 00 00 0a            
000001c
// 00 00 00 41 : A (u+0041) : 基本ラテン文字領域(ASCII互換)
// 00 00 ff 71 : ｱ (u+ff71) : 全角・半角(全角ASCII,半角カナなど)領域
// 00 00 30 a2 : ア(u+30a2) : カタカナ領域
// 00 00 6f 22 : 漢(u+6f22) : CJK統合漢字領域
// 00 00 00 a5 : ¥ (u+00a5) : ラテン補助領域
// 00 00 00 5c : \ (u+005c) : 基本ラテン文字領域(ASCII互換)
// 00 00 00 0a : LF(u+000a) : 基本ラテン文字領域(ASCII互換)
// Unicode値とJIS X 0208漢字コードに関連性なし(対応に規則性なし)

// UTF-8 にエンコードされた状態を16進ダンプ
$ hexdump x0208UTF8.txt
0000000 41 ef bd b1 e3 82 a2 e6 bc a2 c2 a5 5c 0a      
000000e
// 41       : 01000001                   : A (u+0041)
// ef bd b1 : 11101111 10111101 10110001 : ｱ (u+ff71)
// e3 82 a2 : 11100011 10000010 10100010 : ア(u+30a2)
// e6 bc a2 : 11100110 10111100 10100010 : 漢(u+6f22)
// c2 a5    : 11000010 10100101          : ¥ (u+00a5)
// 5c       : 01011100                   : \ (u+005c)
// 0a       : 00001010                   : LF(u+000a)

// EUC-JP にエンコードされた状態を16進ダンプ
$ iconv -f UTF-8 -t EUC-JP x0208UTF8.txt | hexdump
0000000 41 8e b1 a5 a2 b4 c1 5c 5c 0a                  
000000a
// 41    : A (0x41)   : ASCIIコード
// 8e b1 : ｱ (0x8eb1) : JIS X 0201半角カナコード('ｱ':0xb1)は、例
//                      外的に前に 0x8e を付加してエンコードする
// a5 a2 : ア(0xa5a2) : JIS X 0208コード('ア':0x2522)に +0x8080
// b4 c1 : 漢(0x3441) : JIS X 0208コード('漢':0x3441)に +0x8080
// 5c    : ¥ (0x5c)   : ASCIIコード('\':0x5c)と区別がつかない 
//                      EUCでは JIS X 0201は扱えない
// 5c    : \ (0x5c)   : ASCIIコード
// 0a    : LF(0x0a)   : ASCIIコード


// SJIS にエンコードされた状態を16進ダンプ
$ iconv -f UTF-8 -t SJIS x0208UTF8.txt | hexdump
iconv: x0208UTF8.txt:1:7: cannot convert
0000000 41 b1 83 41 8a bf 5c                           
0000007
// 41    : A (0x41)   : JIS X 0201コード
// b1    : ｱ (0xb1)   : JIS X 0201コード
// 83 41 : ア(0x8341) : JIS X 0208コード(0x2522)を計算で変換
// 8a bf : 漢(0x8abf) : JIS X 0208コード(0x3441)を計算で変換
// 5c    : ¥ (0x5c)   : JIS X 0201コード
// エラー: '\'はJIS X 0201に含まれないのでエラー
// 

// ISO-2022-JP にエンコードされた状態を16進ダンプ
$ iconv -f UTF-8 -t ISO-2022-JP x0208UTF8.txt | hexdump
iconv: x0208UTF8.txt:1:1: cannot convert
0000000 41
0000001
// 半角カナでエラーが発生する。
// 実は ISO-2022-JP は半角カナを許容しない。(メールで半角カナ不可)
// "ESC ( J"はJIS X 0201のラテン文字(0x7f以下)へ切換える。
//
// iconvで半角カナが使用できるエンコーディング方式は ISO-2022-JP
// の改良版ISO-2022-JP-2, ISO-2022-JP-3, ISO-2022-JP-2004 だけ。
// (正式なISO-2022-JP-2,ISO-2022-JP-3,ISO-2022-JP-2004規格が半角
// カナを扱えるかどうかは調べた範囲では不明。恐らくiconvの独自拡張)
//
// iconvは半角カナを表現するためにエスケープシーケンス"ESC ( I"を
// 使用する。これは、JIS X 0201 のカナ領域へ切換える。
// 切換えた後は、半角カナコードから0x80を引いて7bitで表現する。
// "ESC ( I"による文字集合切換えは、別規格にあり流用と考えられる。
//
// ISO-2022-JPでエンコードした結果は7bitの範囲におさまる。
// ASCII(7bit)のみ想定の通信回線やプログラムを通過可の場合が多い
//   => メールサーバが古く7bitしか通さなくてもメールの配信が可能
//   => 日本語メールのエンコーディングに使用される

// iconv の ISO-2022-JP-2004 にエンコードされた状態を16進ダンプ
$ iconv -f UTF-8 -t ISO-2022-JP-2004 x0208UTF8.txt | hexdump
0000000 41 1b 28 49 31 1b 24 42 25 22 34 41 1b 28 4a 5c
0000010 1b 28 42 5c 0a                                 
0000015
// 41       : A        : ASCIIコード('A':0x41)
// 1b 28 49 : ESC ( I  : JIS X 0201の半角カナへ切換える
// 31       : ｱ        : この状態では('ｱ':0xb1)から0x80を引いて
//                       0x31 で表現する
// 1b 24 42 : ESC $ B  : JIS X 0208に切換える
// 25 22    : ア       : JIS X 0208コード('ア':0x2522)
// 34 41    : 漢       : JIS X 0208コード('漢':0x3441)
// 1b 28 4a : ESC ( J  : JIS X 0201(ローマ字)に切換える
// 5c       : ¥        : JIS X 0201コード('¥':0x5c)
// 1b 28 42 : ESC ( B  : ASCIIに切換える
// 5c       : \        : ASCIIコード('\':0x5c)
// 0a       : LF       : ASCIIコード(LF:0x0a)